<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>WebGPU Logical NN</title>
    </head>
    <body>
        <script type="module">
            async function main() {
                if (!navigator.gpu) {
                    console.error("WebGPU not supported on this browser.");
                    return;
                }
                const adapter = await navigator.gpu.requestAdapter();
                const device = await adapter.requestDevice();

                // AND gate inputs and targets
                const inputs = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
                const targets = new Float32Array([0, 0, 0, 1]);

                // Buffers for inputs, targets, weights, and outputs
                const inputBuffer = device.createBuffer({
                    size: inputs.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: true,
                });
                new Float32Array(inputBuffer.getMappedRange()).set(inputs);
                inputBuffer.unmap();

                const targetBuffer = device.createBuffer({
                    size: targets.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: true,
                });
                new Float32Array(targetBuffer.getMappedRange()).set(targets);
                targetBuffer.unmap();

                const weightBuffer = device.createBuffer({
                    size: 3 * Float32Array.BYTES_PER_ELEMENT, // 2 weights + 1 bias
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: true,
                });
                new Float32Array(weightBuffer.getMappedRange()).set([0.5, 0.5, -1.0]); // Random init weights
                weightBuffer.unmap();

                const outputBuffer = device.createBuffer({
                    size: 4 * Float32Array.BYTES_PER_ELEMENT,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
                });

                const shaderModule = device.createShaderModule({
                    code: `
                    @group(0) @binding(0) var<storage, read> inputs: array<f32>;
                    @group(0) @binding(1) var<storage, read> weights: array<f32>;
                    @group(0) @binding(2) var<storage, read_write> outputs: array<f32>;

                    @compute @workgroup_size(1)
                    fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                        let idx = id.x;
                        let x1 = inputs[idx * 2];
                        let x2 = inputs[idx * 2 + 1];
                        let w1 = weights[0];
                        let w2 = weights[1];
                        let bias = weights[2];
                        let sum = x1 * w1 + x2 * w2 + bias;

                        // Sigmoid activation
                        outputs[idx] = 1.0 / (1.0 + exp(-sum));
                    }`
                });

                const bindGroupLayout = device.createBindGroupLayout({
                    entries: [
                        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
                        { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },
                    ],
                });

                const pipelineLayout = device.createPipelineLayout({
                    bindGroupLayouts: [bindGroupLayout],
                });

                const computePipeline = device.createComputePipeline({
                    layout: pipelineLayout,
                    compute: { module: shaderModule, entryPoint: "main" },
                });

                const bindGroup = device.createBindGroup({
                    layout: computePipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: inputBuffer } },
                        { binding: 1, resource: { buffer: weightBuffer } },
                        { binding: 2, resource: { buffer: outputBuffer } },
                    ],
                });

                const commandEncoder = device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(computePipeline);
                passEncoder.setBindGroup(0, bindGroup);
                passEncoder.dispatchWorkgroups(4); // 4 workgroups for 4 inputs
                passEncoder.end();

                device.queue.submit([ commandEncoder.finish() ]);

                // Copy output buffer to a read buffer
                const readBuffer = device.createBuffer({
                    size: outputBuffer.size,
                    usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                });

                const copyCommandEncoder = device.createCommandEncoder();
                copyCommandEncoder.copyBufferToBuffer(outputBuffer, 0, readBuffer, 0, outputBuffer.size);
                device.queue.submit([copyCommandEncoder.finish()]);

                // Wait for the read buffer to be ready and map it
                await readBuffer.mapAsync(GPUMapMode.READ);
                const resultArray = new Float32Array(readBuffer.getMappedRange());
                console.log("Outputs:", Array.from(resultArray));
            }
            main();
        </script>
    </body>
</html>
